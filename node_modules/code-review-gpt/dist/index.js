#!/usr/bin/env node
"use strict";var Dt=Object.create;var U=Object.defineProperty;var qt=Object.getOwnPropertyDescriptor;var Kt=Object.getOwnPropertyNames;var Ut=Object.getPrototypeOf,Yt=Object.prototype.hasOwnProperty;var m=(e,t)=>()=>(e&&(t=e(e=0)),t);var x=(e,t)=>{for(var r in t)U(e,r,{get:t[r],enumerable:!0})},Jt=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Kt(t))!Yt.call(e,n)&&n!==r&&U(e,n,{get:()=>t[n],enumerable:!(o=qt(t,n))||o.enumerable});return e};var d=(e,t,r)=>(r=e!=null?Dt(Ut(e)):{},Jt(t||!e||!e.__esModule?U(r,"default",{value:e,enumerable:!0}):r,e));var b=m(()=>{"use strict"});var pe,s,g=m(()=>{"use strict";pe=require("tslog"),s=new pe.Logger({prettyLogTemplate:"{{logLevelName}}	"})});var fe={};x(fe,{configure:()=>Vt});var w,P,S,Vt,zt,Qt,he=m(()=>{"use strict";w=d(require("fs")),P=d(require("path")),S=require("child_process");g();b();Vt=async e=>{e.setupTarget==="github"&&zt(),e.setupTarget==="gitlab"&&Qt()},zt=async()=>{let e=w.default.readFileSync(P.default.join(__dirname,"github-pr.yml"),"utf8"),t=P.default.join(process.cwd(),".github","workflows");w.default.mkdirSync(t,{recursive:!0});let r=P.default.join(t,"code-review-gpt.yml");w.default.writeFileSync(r,e,"utf8"),s.info(`Created GitHub Actions workflow at: ${r}`);let o=await import("inquirer"),{apiKey:n}=await o.default.prompt([{type:"input",name:"apiKey",message:"Please input your OpenAI API key:",mask:"*"}]);if(!n){s.error("No API key provided. Please manually add the OPENAI_API_KEY secret to your GitHub repository.");return}try{(0,S.execSync)("gh auth status || gh auth login",{stdio:"inherit"}),(0,S.execSync)(`gh secret set OPENAI_API_KEY --body=${n}`),s.info("Successfully added the OPENAI_API_KEY secret to your GitHub repository.")}catch{s.error("It seems that the GitHub CLI is not installed or there was an error during authentication. Don't forget to add the OPENAI_API_KEY to the repo settings/Environment/Actions/Repository Secrets manually.")}},Qt=async()=>{let e=w.default.readFileSync(P.default.join(__dirname,"gitlab-pr.yml"),"utf8"),t=process.cwd();w.default.mkdirSync(t,{recursive:!0});let r=P.default.join(t,".gitlab-ci.yml");w.default.writeFileSync(r,e,"utf8"),s.info(`Created GitLab CI at: ${r}`);let o=await import("inquirer"),{apiKey:n}=await o.default.prompt([{type:"input",name:"apiKey",message:"Please input your OpenAI API key:",mask:"*"}]);if(!n){s.error("No API key provided. Please manually add the OPENAI_API_KEY secret to your GitLab CI/CD environment variables for your repository.");return}try{(0,S.execSync)("glab auth login",{stdio:"inherit"}),(0,S.execSync)(`glab variable set OPENAI_API_KEY ${n}`),s.info("Successfully added the OPENAI_API_KEY secret to your GitLab repository.")}catch{s.error("It seems that the GitLab CLI is not installed or there was an error during authentication. Don't forget to add the OPENAI_API_KEY to the repo's CI/CD Variables manually.")}}});var T,R,v,y=m(()=>{"use strict";g();T=()=>{if(!process.env.OPENAI_API_KEY)throw new Error("OPENAI_API_KEY is not set");return process.env.OPENAI_API_KEY},R=()=>{let e=["GITHUB_SHA","BASE_SHA","GITHUB_TOKEN"].filter(t=>!process.env[t]);if(e.length>0)throw s.error(`Missing environment variables: ${e.join(", ")}`),new Error("One or more GitHub environment variables are not set");return{githubSha:process.env.GITHUB_SHA,baseSha:process.env.BASE_SHA,githubToken:process.env.GITHUB_TOKEN}},v=()=>{let e=["CI_MERGE_REQUEST_DIFF_BASE_SHA","CI_PROJECT_ID","CI_MERGE_REQUEST_IID","CI_COMMIT_SHA","GITLAB_TOKEN"].filter(t=>!process.env[t]);if(e.length>0)throw s.error(`Missing environment variables: ${e.join(", ")}`),new Error("One or more GitLab environment variables are not set");return{mergeRequestBaseSha:process.env.CI_MERGE_REQUEST_DIFF_BASE_SHA,gitlabSha:process.env.CI_COMMIT_SHA,gitlabToken:process.env.GITLAB_TOKEN,projectId:process.env.CI_PROJECT_ID,mergeRequestIIdString:process.env.CI_MERGE_REQUEST_IID}}});var C,Xt,Y,be,we,J=m(()=>{"use strict";y();C=require("@actions/github");g();Xt=(e,t)=>{let r=e.lastIndexOf(t);return r!==-1?e.slice(r+t.length+1):e},Y=()=>{let{githubToken:e}=R();if(!e)throw new Error("GITHUB_TOKEN is not set");return e},be=()=>{let e=Y(),{payload:t,issue:r}=C.context;if(!t.pull_request){s.warn("Not a pull request. Skipping commenting on PR...");return}let o=(0,C.getOctokit)(e),{owner:n,repo:i,number:a}=r;return{octokit:o,owner:n,repo:i,pull_number:a}},we=async(e,t)=>{try{let r=`${t.feedback.details}

---

${t.signOff}`,{data:o}=await e.rest.pulls.listReviewComments({owner:t.owner,repo:t.repo,pull_number:t.pull_number}),n=Xt(t.feedback.fileName,t.repo),i=o.find(a=>a?.path===n&&a?.body?.includes(t.signOff));i?e.rest.pulls.updateReviewComment({owner:t.owner,repo:t.repo,comment_id:i.id,body:r}):await e.rest.pulls.createReviewComment({owner:t.owner,repo:t.repo,pull_number:t.pull_number,body:r,commit_id:t.commit_id,path:n,subject_type:"FILE"})}catch(r){s.error(`Failed to comment on PR for feedback: ${t.feedback.details}. Error: ${r}`)}}});var E,_,W=m(()=>{"use strict";E=require("@actions/github");J();g();_=async(e,t)=>{try{let r=Y(),{payload:o,issue:n}=E.context;if(!o.pull_request){s.warn("Not a pull request. Skipping commenting on PR...");return}let i=(0,E.getOctokit)(r),{owner:a,repo:c,number:l}=n,{data:p}=await i.rest.issues.listComments({owner:a,repo:c,issue_number:l}),u=p.find(F=>F?.body?.includes(t)),f=`${e}

---

${t}`;u?await i.rest.issues.updateComment({owner:a,repo:c,comment_id:u.id,body:f}):await i.rest.issues.createComment({owner:a,repo:c,issue_number:l,body:f})}catch(r){throw s.error(`Failed to comment on PR: ${r}`),r}}});var ye,Ie=m(()=>{"use strict";J();ye=async(e,t)=>{let r=be();if(r){let{octokit:o,owner:n,repo:i,pull_number:a}=r,l=(await o.rest.pulls.get({owner:n,repo:i,pull_number:a})).data.head.sha;for(let p of e)we(o,{feedback:p,signOff:t,owner:n,repo:i,pull_number:a,commit_id:l})}}});var Pe,O,V=m(()=>{"use strict";Pe=require("@gitbeaker/rest");y();g();O=async(e,t)=>{try{let{gitlabToken:r,projectId:o,mergeRequestIIdString:n}=v(),i=parseInt(n,10),a=new Pe.Gitlab({token:r}),l=(await a.MergeRequestNotes.all(o,i)).find(u=>u?.body?.includes(t)),p=`${e}

---

${t}`;l?await a.MergeRequestNotes.edit(o,i,l.id,{body:p}):await a.MergeRequestNotes.create(o,i,p)}catch(r){throw s.error(`Failed to comment on PR: ${r}`),r}}});var $,z,Q,Re,ve,ke,Fe,I=m(()=>{"use strict";$="#### Powered by [Code Review GPT](https://github.com/mattzcarey/code-review-gpt)",z=[{model:"gpt-4",maxPromptLength:21e3},{model:"gpt-4-32k",maxPromptLength:9e4},{model:"gpt-3.5-turbo",maxPromptLength:9e3},{model:"gpt-3.5-turbo-16k",maxPromptLength:45e3}],Q={".js":"JavaScript",".ts":"TypeScript",".py":"Python",".sh":"Shell",".go":"Go",".rs":"Rust",".tsx":"TypeScript",".jsx":"JavaScript",".dart":"Dart",".php":"PHP"},Re=new Set(Object.keys(Q)),ve=new Set(["types"]),ke=3,Fe=5});var L,X=m(()=>{"use strict";I();L=e=>{let t=z.find(r=>r.model===e)?.maxPromptLength;if(!t)throw new Error(`Model ${e} not found. Please choose one of ${z.map(r=>r.model)} or make a PR to add a new model.`);return t}});var Zt,er,tr,Ae,Se=m(()=>{"use strict";Zt=(e,t)=>{let r=new RegExp(`"${e}"\\s*:\\s*"((?:[^"\\\\]|\\\\.)*)"`,"g");return t.replace(r,(o,n)=>`"${e}": "${encodeURIComponent(n)}"`)},er=e=>decodeURIComponent(e).replace(/\\n/g,`
`),tr=(e,t,r)=>{t.forEach(o=>{e[o]&&(e[o]=r(e[o]))})},Ae=(e,t)=>{let r=e;t.forEach(n=>{r=Zt(n,r)});let o=JSON.parse(r);return Array.isArray(o)&&o.forEach(n=>{tr(n,t,er)}),o}});var xe,Te,rr,Z,N,ee=m(()=>{"use strict";xe=require("langchain/llms/openai"),Te=require("ts-retry");g();Se();rr=3,Z=class{constructor(t){this.model=new xe.OpenAIChat({openAIApiKey:t.apiKey,modelName:t.modelName,temperature:t.temperature}),this.retryCount=t.retryCount||rr}async callModel(t){return this.model.call(t)}async callModelJSON(t,r=[]){return(0,Te.retryAsync)(async()=>{let o=await this.model.call(t);s.debug(`Model response: ${o}`);try{return Ae(o,r)}catch(n){throw s.error(`Error parsing JSON response from the model: ${o}`,n),n}},{maxTry:this.retryCount,onError:o=>{s.error("Error in callModelJSON",o)},onMaxRetryFunc:()=>{throw new Error(`Couldn't call model after ${this.retryCount} tries with prompt: ${t}`)}})}},N=Z});var te,Ce,re=m(()=>{"use strict";te=`You are an expert {Language} developer, your task is to review a set of pull requests.
You are given a list of filenames and their partial contents, but note that you might not have the full context of the code. 

Only review lines of code which have been changed (added or removed) in the pull request. The code looks similar to the output of a git diff command. Lines which have been removed are prefixed with a minus (-) and lines which have been added are prefixed with a plus (+). Other lines are added to provide context but should be ignored in the review.

Begin your review by evaluating the changed code using a risk score similar to a LOGAF score but measured from 1 to 5, where 1 is the lowest risk to the code base if the code is merged and 5 is the highest risk which would likely break something or be unsafe.

In your feedback, focus on highlighting potential bugs, improving readability if it is a problem, making code cleaner, and maximising the performance of the programming language. Flag any API keys or secrets present in the code in plain text immediately as highest risk. Rate the changes based on SOLID principles if applicable.

Do not comment on breaking functions down into smaller, more manageable functions unless it is a huge problem. Also be aware that there will be libraries and techniques used which you are not familiar with, so do not comment on those unless you are confident that there is a problem.

Use markdown formatting for the feedback details. Also do not include the filename or risk level in the feedback details. 

Ensure the feedback details are brief, concise, accurate. If there are multiple similar issues, only comment on the most critical.

Include brief example code snippets in the feedback details for your suggested changes when you're confident your suggestions are improvements. Use the same programming language as the file under review.
If there are multiple improvements you suggest in the feedback details, use an ordered list to indicate the priority of the changes.

Format the response in a valid JSON format as a list of feedbacks, where the value is an object containing the filename ("fileName"),  risk score ("riskScore") and the feedback ("details"). The schema of the JSON feedback object must be:
{
  "fileName": {
    "type": "string"
  },
  "riskScore": {
    "type": "number"
  },
  "details": {
    "type": "string"
  }
}

The filenames and file contents to review are provided below as a list of JSON objects:

`,Ce=`
You are a senior developer and have just reviewed a pull request. This was your feedback:
{feedback}
Please summarise the review using 3 emojis.
`});var oe,Ee,_e=m(()=>{"use strict";oe=class{constructor(t=[]){this.items=t}enqueue(t,r){let o={priority:r,item:t};this.items.push(o),this.items.sort((n,i)=>n.priority-i.priority)}dequeue(){return this.items.shift()?.item}size(){return this.items.length}peek(){return this.items[0]}getItems(){return this.items.map(t=>t.item)}},Ee=oe});var or,ne,Oe,ie=m(()=>{"use strict";or=e=>`
**Risk Level ${e.riskScore} - ${e.fileName}**

${e.details}

`,ne=e=>`
${e.map(or).join(`
---
`)}
`,Oe=(e,t)=>`
${ne(e)}
---
${t}

`});var nr,$e,ir,sr,Le,Ne=m(()=>{"use strict";g();I();re();_e();ie();nr=async e=>{try{return await e}catch(t){throw s.error("Error in processing prompt",t),t}},$e=async(e,t)=>{let r=Ce.replace("{feedback}",JSON.stringify(t)),o=await e.callModel(r);return s.info(o),o},ir=async(e,t)=>{let r=new Ee;return e.filter(n=>n.riskScore>1).forEach(n=>{r.enqueue(n,n.riskScore+Math.random()),r.size()>t&&r.dequeue()}),r.getItems()},sr=e=>e.reduce((t,r)=>(r.status==="fulfilled"&&t.push(...r.value),t),[]),Le=async(e,t)=>{let r=["details"],o=t.map(c=>e.callModelJSON(c,r)),n=await Promise.allSettled(o.map(nr)),i=sr(n),a=await ir(i,ke);return s.info(ne(a)),a}});var M,se=m(()=>{"use strict";ee();g();y();Ne();ie();M=async(e,t)=>{s.info("Asking the experts...");let r=new N({modelName:t,temperature:0,apiKey:T()}),o=await Le(r,e);s.debug(`Feedback received:
 ${o.map(i=>`Filename: ${i.fileName}, RiskScore: ${i.riskScore}, Details: ${i.details}
`)}`);let n=await $e(r,o);return s.debug(`Summary of feedbacks: ${n}`),{markdownReport:Oe(o,n),feedbacks:o}}});var Me,Ge,Be=m(()=>{"use strict";Me=require("path");I();Ge=e=>{let t=(0,Me.extname)(e);return Q[t]||"Unknown Language"}});var ar,mr,cr,lr,G,ae=m(()=>{"use strict";ar=(e,t)=>{let r={},o=0,n=1/0,i=-1/0,a=new Map;return e.forEach((c,l)=>{let p=c.trim(),u=a.get(p)||[];u.push(l),a.set(p,u)}),t.forEach(c=>{let l=c.substring(1).trim(),p=a.get(l);if(p&&p.length>0){let u=p.shift();r[u]=c,o+=c.length+1,n=Math.min(n,u),i=Math.max(i,u)}}),{changedIndices:r,totalChangedLinesLength:o,minIndex:n,maxIndex:i}},mr=(e,t,r,o)=>{let n=Math.max(e-(o||0),0),i=Math.min(t+(o||0),r-1);return{start:n,end:i}},cr=(e,t,r,o)=>{let n=!0,i=!0;for(;o>0&&(n||i);){if(n&&e>0){let a=r[e-1].length+1;a<=o?(e--,o-=a):n=!1}if(i&&t<r.length-1){let a=r[t+1].length+1;a<=o?(t++,o-=a):i=!1}if((e===0||!n)&&(t===r.length-1||!i))break;e===0&&(n=!1),t===r.length-1&&(i=!1)}return{start:e,end:t}},lr=(e,t,r,o)=>{let n=e>0?`...
`:"";for(let i=e;i<=t;i++)n+=(r[i]||o[i])+`
`;return t<o.length-1&&(n+=`...
`),n.trim()},G=(e,t,r)=>e.map(o=>{let n=o.fileContent.split(`
`),i=o.changedLines.split(`
`),{changedIndices:a,totalChangedLinesLength:c,minIndex:l,maxIndex:p}=ar(n,i),u=t-c-o.fileName.length,{start:f,end:F}=mr(l,p,n.length,r);({start:f,end:F}=cr(f,F,n,u));let jt=lr(f,F,a,n);return{fileName:o.fileName,promptContent:jt}})});var He,je=m(()=>{"use strict";He=e=>e.fileName.length+e.promptContent.length});var k,B=m(()=>{"use strict";g();je();k=(e,t)=>{let r=[],o=[],n=0;for(let i of e){let a=He(i);if(a>t){s.error(`Changes to file ${i.fileName} are larger than the max prompt length, consider using a model with a larger context window. Skipping file changes...`);continue}else n+a>t?(r.push(o),o=[i],n=a):(o.push(i),n+=a)}return o.length>0&&r.push(o),r}});var De,qe=m(()=>{"use strict";ae();B();De=async(e,t)=>{let r=G(e,t);return k(r,t)}});var Ke,Ue=m(()=>{"use strict";I();ae();B();Ke=async(e,t)=>{let r=G(e,t,Fe);return k(r,t)}});var Ye,Je=m(()=>{"use strict";B();Ye=async(e,t)=>{let r=e.map(o=>({fileName:o.fileName,promptContent:o.fileContent.split(`
`).map(n=>`+${n}`).join(`
`)}));return k(r,t)}});var H,me=m(()=>{"use strict";Be();re();qe();Ue();Je();H=async(e,t,r)=>{let o=t-te.length,n;switch(r){case"full":n=await Ye(e,o);break;case"changed":n=await De(e,o);break;case"costOptimized":n=await Ke(e,o);break;default:throw new Error(`Review type ${r} is not supported. Please use one of the following: full, changed, costOptimized.`)}let i=te.replace("{Language}",Ge(e[0].fileName));return n.map(c=>i+JSON.stringify(c))}});var We,ce,Ve=m(()=>{"use strict";We=require("path");I();ce=e=>e.filter(r=>{let o=(0,We.extname)(r.fileName);return Re.has(o)&&![...ve].some(n=>r.fileName.includes(n))&&r.changedLines.trim()!==""})});var ze=m(()=>{"use strict";Ve()});var Qe={};x(Qe,{review:()=>pr});var pr,Xe=m(()=>{"use strict";W();Ie();V();X();b();g();I();se();me();ze();pr=async(e,t)=>{s.debug("Review started."),s.debug(`Model used: ${e.model}`),s.debug(`Ci enabled: ${e.ci}`),s.debug(`Comment per file enabled: ${e.commentPerFile}`),s.debug(`Review type chosen: ${e.reviewType}`);let r=e.ci,o=e.commentPerFile,n=e.model,i=e.reviewType,a=ce(t);if(a.length==0){s.info("No file to review, finishing review now.");return}s.debug(`Files to review after filtering: ${a.map(f=>f.fileName)}`);let c=L(n),l=await H(a,c,i);s.debug(`Prompts used:
 ${l}`);let{markdownReport:p,feedbacks:u}=await M(l,n);s.debug(`Markdown report:
 ${p}`),r==="github"&&(o||await _(p,$),o&&await ye(u,$)),r==="gitlab"&&await O(p,$)}});var Ze,ur,et,tt=m(()=>{"use strict";Ze=require("child_process");y();b();ur=(e,t)=>{if(e==="github"){let{githubSha:r,baseSha:o}=R();return`git diff -U0 --diff-filter=AMRT ${o} ${r} ${t}`}else if(e==="gitlab"){let{gitlabSha:r,mergeRequestBaseSha:o}=v();return`git diff -U0 --diff-filter=AMRT ${o} ${r} ${t}`}return`git diff -U0 --diff-filter=AMRT --cached ${t}`},et=async(e,t)=>{let r=ur(e,t);return new Promise((o,n)=>{(0,Ze.exec)(r,(i,a,c)=>{if(i)n(new Error(`Failed to execute command. Error: ${i.message}`));else if(c)n(new Error(`Command execution error: ${c}`));else{let l=a.split(`
`).filter(p=>p.startsWith("+")||p.startsWith("-")).filter(p=>!p.startsWith("---")&&!p.startsWith("+++")).join(`
`);o(l)}})})}});var rt,ot,gr,nt,it=m(()=>{"use strict";rt=require("child_process"),ot=require("path");y();b();gr=e=>{if(e==="github"){let{githubSha:t,baseSha:r}=R();return`git diff --name-only --diff-filter=AMRT ${r} ${t}`}else if(e==="gitlab"){let{gitlabSha:t,mergeRequestBaseSha:r}=v();return`git diff --name-only --diff-filter=AMRT ${r} ${t}`}return"git diff --name-only --diff-filter=AMRT --cached"},nt=async e=>{let t=gr(e);return new Promise((r,o)=>{(0,rt.exec)(t,(n,i,a)=>{if(n)o(new Error(`Failed to execute command. Error: ${n.message}`));else if(a)o(new Error(`Command execution error: ${a}`));else{let c=i.split(`
`).filter(l=>l.trim()!=="").map(l=>(0,ot.join)(process.cwd(),l.trim()));r(c)}})})}});var mt={};x(mt,{getFilesWithChanges:()=>dr});var st,at,dr,ct=m(()=>{"use strict";st=require("fs/promises"),at=require("process");g();tt();it();dr=async e=>{try{let t=await nt(e);return t.length===0&&(s.warn("No files with changes found, you might need to stage your changes."),(0,at.exit)(0)),await Promise.all(t.map(async o=>{let n=await(0,st.readFile)(o,"utf8"),i=await et(e,o);return{fileName:o,fileContent:n,changedLines:i}}))}catch(t){throw new Error(`Failed to get files with changes: ${t}`)}}});var lt,le,j=m(()=>{"use strict";lt=`
Your role is to help testing a GPT application reviewing code changes. You receive a test case and you need to generate code in typescript corresponding to this test case, even if it follows bad practices or has security issues.
The test cases is formatted as a stringified JSON object with the following properties:
- name: the name of the test case
- description: the description of the test case

The input is the following:
{testCase}

Return the content of a valid typescript file that would pass the test case.
`,le="#### Tests Powered by [Code Review GPT](https://github.com/mattzcarey/code-review-gpt)"});var pt,ut,gt,dt=m(()=>{"use strict";pt=require("langchain/embeddings/openai"),ut=require("langchain/vectorstores/memory"),gt=async e=>{let t=new pt.OpenAIEmbeddings;return await ut.MemoryVectorStore.fromDocuments(e,t,{})}});var ft,ht,bt,fr,wt,yt=m(()=>{"use strict";ft=require("fs"),ht=d(require("path")),bt=require("langchain/document_loaders/fs/text");dt();fr=async e=>await new bt.TextLoader(e).load(),wt=async e=>{let t=(0,ft.readdirSync)(e),r=await Promise.all(t.map(async o=>fr(ht.default.join(e,o))));return await gt(r.flat())}});var D,It,hr,Pt,Rt=m(()=>{"use strict";D=require("fs/promises"),It=d(require("path"));g();hr=async e=>{try{let t=await(0,D.readFile)(e,"utf8");return JSON.parse(t)}catch(t){throw s.error(`Error loading test case: ${e}`),t}},Pt=async e=>{try{let t=(await(0,D.readdir)(e)).filter(r=>r.endsWith(".json"));return Promise.all(t.map(async r=>await hr(It.default.join(e,r))))}catch(t){throw s.error(`Error loading test cases from: ${e}`),t}}});var vt,br,kt,Ft=m(()=>{"use strict";vt=d(require("crypto")),br="sha256",kt=e=>vt.default.createHash(br).update(e).digest("hex")});var q,At,wr,yr,St,xt=m(()=>{"use strict";q=require("fs"),At=d(require("path"));j();Ft();g();wr=async(e,t)=>{let r=lt.replace("{testCase}",JSON.stringify(e));return(await t.callModel(r)).replace("```typescript","").replace("```","")},yr=async(e,t,r)=>{if(e.snippet)return e;let o=kt(e.description),n=At.default.join(t,`${o}.ts`);try{let i=(0,q.readFileSync)(n,"utf8");return{...e,snippet:{fileName:n,fileContent:i,changedLines:i}}}catch{s.info(`Snippet not found in cache: ${e.name}. Generating it...`);let a=await wr(e,r);return(0,q.writeFileSync)(n,a,"utf8"),{...e,snippet:{fileName:n,fileContent:a,changedLines:a}}}},St=async(e,t,r)=>Promise.all(e.map(o=>yr(o,t,r)))});var h,Ct,Ir,Et,_t,Pr,Ot,$t=m(()=>{"use strict";j();h=d(require("chalk")),Ct=(o=>(o.PASS="PASS",o.WARN="WARN",o.FAIL="FAIL",o))(Ct||{}),Ir=e=>e>1-.1?"PASS":e>1-2*.1?"WARN":"FAIL",Et=(e,t)=>{switch(e){case"PASS":return h.default.green(`\u2705 [PASS] - ${t}`);case"WARN":return h.default.yellow(`\u26A0\uFE0F [WARN] - ${t}`);case"FAIL":return h.default.red(`\u274C [FAIL] - ${t}`);default:throw new Error(`Unknown test result: ${e}`)}},_t=(e,t,r,o)=>{let n=Ir(o),i=n!=="PASS",a=Et(n,`Test case: ${e.name} - Similarity score: ${o}
`)+(i?Pr(e,t,r):"");return{result:n,report:a}},Pr=(e,t,r)=>`
 > Test case snippet: ${e.snippet}

===============================================================================

 > Review:
${t}
===============================================================================

> Similar review:
${r}

`,Ot=e=>{let t=Object.entries(e).reduce((o,[n,i])=>o+Et(i,`Test case: ${n}`)+`
`,h.default.blue(`
### Test results summary:
`)),r=Object.values(e).reduce((o,n)=>(o[n]++,o),Object.fromEntries(Object.values(Ct).map(o=>[o,0])));return t+`
**SUMMARY: ${h.default.green(`\u2705 PASS: ${r.PASS}`)} - ${h.default.yellow(`\u26A0\uFE0F WARN: ${r.WARN}`)} - ${h.default.red(`\u274C FAIL: ${r.FAIL}`)}**
`}});var Lt,Rr,Nt,Mt=m(()=>{"use strict";Lt=d(require("chalk"));g();se();me();$t();Rr=async(e,t,r,o,n)=>{if(!e.snippet)throw new Error(`Test case ${e.name} does not have a snippet.`);s.info(Lt.default.blue(`Running test case ${e.name}...`));let i=await H([e.snippet],r,n),{markdownReport:a}=await M(i,t),c=await o.similaritySearchWithScore(a,1);if(c.length===0)throw new Error(`No similar reviews found for test case ${e.name}.`);let[l,p]=c[0],{result:u,report:f}=_t(e,a,l.pageContent,p);return s.info(f),u},Nt=async(e,t,r,o,n)=>{if(e.length===0)return"No test cases found.";s.info(`Running ${e.length} test cases...
`);let i={};for(let c of e)try{let l=await Rr(c,t,r,o,n);i[c.name]=l}catch(l){s.error(`Error running test case ${c.name}:`,l)}let a=Ot(i);return s.info(a),a}});var Gt={};x(Gt,{test:()=>vr});var K,vr,Bt=m(()=>{"use strict";K=d(require("path"));W();V();ee();X();b();y();j();yt();Rt();xt();Mt();vr=async({ci:e,model:t,reviewType:r})=>{let o=L(t),n=await Pt(K.default.join(__dirname,"cases")),i=await St(n,K.default.join(__dirname,"cases/.cache"),new N({modelName:t,temperature:0,apiKey:T()})),a=await wt(K.default.join(__dirname,"cases/snapshots")),c=await Nt(i,t,o,a,r);e==="github"&&await _(c,le),e==="gitlab"&&await O(c,le)}});var Ht=d(require("dotenv"));var ue=d(require("dotenv")),ge=d(require("yargs"));b();g();ue.default.config();var Wt=async()=>{let e=await import("inquirer"),t=[{type:"list",name:"command",message:"What do you want to do?",choices:[{name:"Review the staged files",value:"review"},{name:"Configure the script (Recommended for first time use)",value:"configure"}]}];return(await e.default.prompt(t)).command},de=async()=>{let e=ge.default.option("ci",{description:"Indicates that the script is running on a CI environment. Specifies which platform the script is running on, 'github' or 'gitlab'. Defaults to 'github'.",choices:["github","gitlab"],type:"string",coerce:t=>t||"github"}).option("setupTarget",{description:"Specifies for which platform ('github' or 'gitlab') the project should be configured for. Defaults to 'github'.",choices:["github","gitlab"],type:"string",default:"github"}).option("commentPerFile",{description:"Enables feedback to be made on a file-by-file basis. Only work when the script is running on GitHub.",type:"boolean",default:!1}).option("model",{description:"The model to use for generating the review.",type:"string",default:"gpt-4"}).option("reviewType",{description:"Type of review to perform. 'full' will review the entire file, 'changed' will review the changed lines only but provide the full file as context if possible. 'costOptimized' will review only the changed lines using the least tokens possible to keep api costs low. Defaults to 'changed'.",choices:["full","changed","costOptimized"],type:"string",default:"changed"}).option("debug",{description:"Enables debug logging.",type:"boolean",default:!1}).command("review","Review the pull request.").command("configure","Configure the script.").parseSync();if(e._[0]||(e._[0]=await Wt()),e.shouldCommentPerFile&&!e.isCi)throw new Error("The 'commentPerFile' flag requires the 'ci' flag to be set.");return e.isCi==="gitlab"&&e.shouldCommentPerFile&&s.warn("The 'commentPerFile' flag only works for GitHub, not for GitLab."),e};g();Ht.default.config();var kr=async()=>{let e=await de();switch(s.settings.minLevel=e.debug?2:e.ci?4:3,e._[0]){case"configure":let{configure:t}=await Promise.resolve().then(()=>(he(),fe));await t(e);break;case"review":let{review:r}=await Promise.resolve().then(()=>(Xe(),Qe)),{getFilesWithChanges:o}=await Promise.resolve().then(()=>(ct(),mt)),n=await o(e.ci);await r(e,n);break;case"test":let{test:i}=await Promise.resolve().then(()=>(Bt(),Gt));await i(e);break;default:s.error("Unknown command"),process.exit(1)}};kr().catch(e=>{s.error(`Error: ${e}`),process.exit(1)});
